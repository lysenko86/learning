# вказуємо скачати образ з назвою node:13 (ядро Linux з 13-ою нодою)
# береться з hub.docker.com, бо хтось його раніше вже збілдив і залив
# це майбутнє наше середовище, качається на локальну машину
#FROM node:13

# зазвичай в багатьох образах є версія alpine - її відмінність - значно менше об'єм, версія де видалено все зайве
FROM node:13.12.0-alpine

# вказуємо робочий каталог нашої аплікухи всередині нашого середовища (контейнера)
WORKDIR /usr/src/app

# копіює файли по маскі (package.json та package-lock.json) в кореневу директорію, яку ми задали вище (/usr/src/app)
COPY package*.json ./

# Команда RUN запускає всякі команди командної строки
RUN npm install

# копіює все з кореневого каталогу в кореневий заданий вище каталог
# ігнорує все, що вписано в файлі .dockerignore
COPY . .

# Ця команда відкриває заданий порт із контейнеру в зовнішній світ, в нашому випадку 3020
# тобто cама аплікуха в нас запуститься на порті 3020 всередині контейнера,
# але і доступ у контейнер буде за таким самим потром
# EXPOSE 3020
# але тут краще не задавати конкретний порт

# Ця команда запускає наш веб сервер
# CMD ['node', 'run start']
# так само тут краще не писати тут такі команди

# порт і команди краще задавати на рівні docker-compose
# щоб сам контейнер не знав нічого про змінні середовища
# подібно до stateless компонентс, тільки це контейнер
# причина, наприклад задати різні порти для дева і прода і це треба буде зробити
# лише в одному місці - docker-compose а не в кожному Dockerfile
